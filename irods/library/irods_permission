#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Â© 2023 The Arizona Board of Regents on behalf of The University of Arizona.
# For license information, see https://cyverse.org/license.

"""Provides an ansible module for creating and removing iRODS collection."""

from enum import Enum
from functools import cached_property
import ssl
from os.path import basename, dirname
import traceback
from typing import Optional, Union

__metaclass__ = type


DOCUMENTATION = r'''
---
module: irods_permission

short_description: This module modifies iRODS ACLs.

description: >
    This module is able to add or remove a permission to collection or data
    object's ACL. For a collection, it is able to add or remove a permission
    recursively to the ACLs of all of the collection's members.

version_added: "2.9.0"

author:
    - John Xu
    - Tony Edgin

options:
    zone:
        description: This is the iRODS zone where the change is being made.
        required: true
        type: str
    subject:
        description: This is the username of the user receiving the permission.
        required: true
        type: str
    subject_zone:
        description: This is the iRODS zone the subject belongs to.
        required: false
        default: O(zone)
        type: str
    permission:
        description: This is the type of permission being assigned.
        required: true
        choices:
            - null
            - read
            - write
            - own
        type: str
    object:
        description:
            - This is the object receiving the permission.
            - It can be a collection or data object.
        required: true
        type: str
    recursive:
        description:
            - >
                This indicates if the permission should be assigned
                recursively to everything in a collection as well.
            - This is ignored for a data object.
        required: false
        default: false
        type: bool
    admin_user:
        description:
            - This is the iRODS username to authorize the change.
            - This should be a rodsadmin type user.
        required: false
        default: rods
        type: str
    admin_password: This is the password used to authenticate O(admin_user).
        required: true
        type: str
    host:
        description: >
            This is the name of the iRODS server to connect to when making the
            change.
        required: false
        default: localhost
        type: str
    port:
        description: This is the TCP port to connect to on the iRODS server.
        required: false
        default: 1247
        type: int

requirements:
    - python-irodsclient>=0.8.2
'''

EXAMPLES = r'''
- name: ensure anonymous user has read access to required collections
  irods_permission:
    subject: anonymous
    permission: read
    object: /tempZone/home/test_collection
    host: cyverse.org
    port: 1247
    admin_user: rods
    admin_password: 1234
    zone: tempZone

- name: give ownership of a collection to a user
  irods_permission:
    subject: test_user123
    permission: own
    object: /tempZone/home/test_collection
    host: cyverse.org
    port: 1247
    admin_user: rods
    admin_password: 1234
    zone: tempZone
'''

RETURN = r'''
perm_before:
    description:
        - >
            The permission the user has on O(object) before the module changes
            anything.
        - >
            Regardless of the value of O(recursive), only the permission of
            O(object) will be returned.
        - The possible values are V(null), V(read), V(write), and V(own).
    returned: success
    type: str
perm_after:
    description:
        - >
            The permission the user has on O(object) after the module makes any
            changes.
        - >
            Regardless of the value of O(recursive), only the permission of
            O(object) will be returned.
        - The possible values are V(null), V(read), V(write), and V(own).
    returned: changed
    type: str
'''

from ansible.module_utils.basic import AnsibleModule

_IRODSCLIENT_PACK_ERR: Optional[Exception] = None

try:
    from irods.session import iRODSSession
    from irods.models import Collection, CollectionAccess, CollectionUser, DataObject, DataAccess, \
        User
    from irods.access import iRODSAccess
    from irods.exception import DataObjectDoesNotExist
    from irods.column import Like
except ImportError as e:
    _IRODSCLIENT_PACK_ERR = e


_ARG_SPEC = {
    "zone": {
        "type": "str",
        "required": True,
    },
    "subject": {
        "type": "str",
        "required": True,
    },
    "subject_zone": {
        "type": "str",
        "required": False,
    },
    "permission": {
        "type": "str",
        "choices": [ "null", "read", "write", "own" ],
        "required": True,
    },
    "object": {
        "type": "str",
        "required": True,
    },
    "recursive": {
        "type": "bool",
        "default": False,
        "required": False,
    },
    "admin_user": {
        "type": "str",
        "default": "rods",
        "required": False,
    },
    "admin_password": {
        "type": "str",
        "required": True,
        "no_log": True,
    },
    "host": {
        "type": "str",
        "default": "localhost",
        "required": False,
    },
    "port": {
        "type": "int",
        "default": 1247,
        "required": False,
    },
}


class _Permission(Enum):
    null = 1000
    read = 1050
    write = 1120
    own = 1200

    @classmethod
    def _missing_(cls, value):
        if value is None:
            return cls.null
        if type(value) != str:
            return None
        for member in cls:
            if member.name == value.lower():
                return member
        return None


class _Result:
    def __init__(self):
        self._success = False
        self._changed = False
        self._failure_reason = ""
        self._init_perm = None
        self._final_perm = None

    def as_failure(self, reason: str = ""):
        """
        Makes this result into a failed result

        Args:
            msg  a message describing the failure

        Returns:
            the updated _Result object
        """
        self._success = False
        self._failure_reason = reason
        return self

    def as_success(self):
        """
        Makes this result into a success result

        Returns:
            the updated _Result object
        """
        self._success = True
        return self

    def made_changes(self):
        """
        Modifies the result to indicate that changes where made.

        Returns:
            the updated _Result object
        """
        self._changed = True
        return self

    @property
    def changed(self) -> bool:
        """Indicates whether or not a change was made"""
        return self._changed

    @property
    def success(self) -> bool:
        """Indicates if the operation was successful"""
        return self._success

    @property
    def failure_reason(self) -> str:
        """This may provide a reason why on operation failed"""
        return self._failure_reason

    @property
    def initial_permission(self) -> Optional[_Permission]:
        """the initial permission, if it was determined"""
        return self._init_perm

    @initial_permission.setter
    def initial_permission(self, perm: _Permission):
        self._init_perm = perm

    @property
    def final_permission(self) -> Optional[_Permission]:
        """the final permission, if it was determined"""
        return self._final_perm

    @final_permission.setter
    def final_permission(self, perm: _Permission):
        self._final_perm = perm


class _PermOp:

    def __init__(self, params, session):
        self._session = session
        self._subject_zone = params["subject_zone"]
        self._subject_name = params["subject"]
        self._target_perm = _Permission(params["permission"])
        self._object_path = params["object"]
        self._recursive = params["recursive"]

    @cached_property
    def result(self) -> _Result:
        """This is the result of the operation."""
        result = _Result()
        if not self.subject_exists:
            return result.as_failure(f"user {self.subject_name}#{self.subject_zone} does not exist")
        if not self.object_exists:
            return result.as_failure(f"object {self.object_path} does not exist")
        result.initial_permission = self.current_permission
        if self.needs_changes():
            self._update_permission()
            result.made_changes()
        result.final_permission = self.current_permission
        return result.as_success()

    def needs_changes(self) -> bool:
        """
        This method indicates whether or not an operation needs to make changes.

        Returns:
            True is changes need to be made, otherwise False

        This method is abstract and needs to be implemented by its derived
        classes.
        """
        pass

    @property
    def object_path(self) -> str:
        """This is the path to the object receiving the permission."""
        return self._object_path

    @cached_property
    def object_type(self) -> Union[Collection, DataObject, None]:
        """This is the type of the object receiving the permission."""
        query = self._session.query(Collection).filter(Collection.name == self.object_path)
        if query.first():
            return Collection
        try:
            self._session.data_objects.get(self.object_path)
            return DataObject
        except DataObjectDoesNotExist:
            return None

    @property
    def object_exists(self) -> bool:
        """Indicates whether or not this object exists in the iRODS zone"""
        return self.object_type is not None

    @property
    def subject_name(self) -> str:
        """
        This is the username of the user receiving permission on the object.
        """
        return self._subject_name

    @property
    def subject_zone(self) -> str:
        """The user receiving permission belongs to this zone."""
        return self._subject_zone

    @cached_property
    def subject_id(self) -> Optional[int]:
        """
        This is the ICAT DB Id of the subject receiving permission on the
        object.
        """
        cond = [ User.name == self.subject_name, User.zone == self.subject_zone ]
        query = self._session.query(User.id).filter(*cond)
        return query.first()[User.id] if query.first() else None

    @property
    def subject_exists(self) -> bool:
        """Indicates whether or no the subject exists in the iRODS zone."""
        return self.subject_id is not None

    @property
    def target_permission(self) -> _Permission:
        """This is the permission that will be set on the object."""
        return self._target_perm

    @cached_property
    def current_permission(self) -> _Permission:
        """This is the current permission of the object."""
        if self.object_type == Collection:
            conditions = [
                Collection.name == self.object_path,
# XXX - User.id doesn't condition correctly in this case in iRODS 4.2.8
#                 User.id == self.subject_id,
                CollectionUser.name == self.subject_name,
                CollectionUser.zone == self.subject_zone,
# XXX - ^^^
            ]
            query = self._session.query(CollectionAccess.type).filter(*conditions)
            if query.first():
                return _Permission(query.first()[CollectionAccess.type])
        if self.object_type == DataObject:
            conditions = [
                Collection.name == dirname(self.object_path),
                DataObject.name == basename(self.object_path),
# XXX - User.id doesn't condition correctly in this case in iRODS 4.2.8
#                 User.id == self.subject_id,
                User.name == self.subject_name,
                User.zone == self.subject_zone,
# XXX - ^^^
            ]
            query = self._session.query(DataAccess.type).filter(*conditions)
            if query.first():
                return _Permission(query.first()[DataAccess.type])
        return _Permission.null

    def _update_permission(self):
        access = iRODSAccess(
            self.target_permission.name, self.object_path, self.subject_name, self._subject_zone)
        self._session.permissions.set(access, recursive=self.recursive)
        self.current_permission = self.target_permission

    @property
    def recursive(self) -> bool:
        """
        Indicates if all members of the object will receive the permission as
        well.
        """
        return self._recursive and self.object_type == Collection


class _PermAbsent(_PermOp):

    def needs_changes(self):
        if not self.recursive:
            return self.current_permission != _Permission.null
        return self._count_coll_perms() > 0 or self._count_data_perms() > 0

    def _count_coll_perms(self):
        cond = [
            Like(Collection.name, f"{self.object_path}%"),
            CollectionAccess.user_id == self.subject_id,
        ]
        query = self._session.query().count(CollectionAccess.access_id).filter(*cond)
        return query.first()[CollectionAccess.access_id]

    def _count_data_perms(self):
        cond = [
            Like(Collection.name, f"{self.object_path}%"),
            DataAccess.user_id == self.subject_id,
        ]
        query = self._session.query().count(DataAccess.data_id).filter(*cond)
        return query.first()[DataAccess.data_id]


class _PermPresent(_PermOp):

    def needs_changes(self):
        if not self.recursive:
            return self.current_permission != self.target_permission
        if self._count_colls_with_tgt_perm() != self._count_all_colls():
            return True
        if self._count_data_with_tgt_perm() != self._count_all_data():
            return True
        return False

    def _count_all_colls(self):
        query = (
            self._session.query()
            .count(Collection.id)
            .filter(Like(Collection.name, f"{self.object_path}/%")) )

        # 1 parent collection + subcollections
        return 1 + query.first()[Collection.id]

    def _count_colls_with_tgt_perm(self):
        acl_cond = [
            CollectionAccess.type == self.target_permission.value,
            CollectionAccess.user_id == self.subject_id,
        ]
        base_query = (
            self._session.query()
            .count(Collection.id)
            .filter(Collection.name == self.object_path)
            .filter(*acl_cond) )
        sub_query = (
            self._session.query()
            .count(Collection.id)
            .filter(Like(Collection.name, f"{self.object_path}/%"))
            .filter(*acl_cond) )
        return base_query.first()[Collection.id] + sub_query.first()[Collection.id]

    def _count_all_data(self):
        base_query = (
            self._session.query().count(DataObject.id).filter(Collection.name == self.object_path) )
        sub_query = (
            self._session.query()
            .count(DataObject.id)
            .filter(Like(Collection.name, f"{self.object_path}/%")) )
        return base_query.first()[DataObject.id] + sub_query.first()[DataObject.id]

    def _count_data_with_tgt_perm(self):
        acl_cond = [
            DataAccess.type == self.target_permission.value,
            DataAccess.user_id == self.subject_id,
        ]
        base_query = (
            self._session.query()
            .count(DataAccess.data_id)
            .filter(Collection.name == self.object_path) )
        sub_query = (
            self._session.query()
            .count(DataAccess.data_id)
            .filter(Like(Collection.name, f"{self.object_path}/%"))
            .filter(*acl_cond) )
        return base_query.first()[DataAccess.data_id] + sub_query.first()[DataAccess.data_id]


class IrodsPermission(AnsibleModule):
    """Module class"""

    def __init__(self):
        super().__init__(argument_spec=_ARG_SPEC, supports_check_mode=True)
        if not self.params["subject_zone"]:
            self.params["subject_zone"] = self.params["zone"]

    def run(self) -> None:
        """performs the business logic of the module"""
        if self.check_mode:
            self.exit_json(**self._result)
            return
        try:
            with self._init_session() as session:
                action = self._select_action(session)
                result = action.result
                if result.success:
                    resp = {
                        "changed": result.changed,
                        "perm_before": result.initial_permission.name,
                        "perm_after": result.final_permission.name }
                    self.exit_json(**resp)
                else:
                    self.fail_json(msg=result.failure_reason)
        except Exception:  # pylint: disable=broad-exception-caught
            tmpl = "An unexpected exception occurred:\n{0}"
            self.fail_json(msg=tmpl.format(traceback.format_exc()))

    def _init_session(self):
        ssl_context = ssl.create_default_context(
            purpose=ssl.Purpose.SERVER_AUTH,
            cafile=None,
            capath=None,
            cadata=None)
        ssl_settings = {"ssl_context": ssl_context}
        return iRODSSession(
            host=self.params["host"],
            port=self.params["port"],
            user=self.params["admin_user"],
            password=self.params["admin_password"],
            zone=self.params["zone"],
            **ssl_settings)

    def _select_action(self, session):
        if self.params["permission"] == "null":
            return _PermAbsent(self.params, session)
        return _PermPresent(self.params, session)


def main() -> None:
    module = IrodsPermission()
    if _IRODSCLIENT_PACK_ERR:
        module.fail_json(msg=f"python-irodsclient not installed\n{_IRODSCLIENT_PACK_ERR}")
        return
    module.run()


if __name__ == "__main__":
    main()
